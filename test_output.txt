============================= test session starts =============================
platform win32 -- Python 3.12.10, pytest-8.4.2, pluggy-1.6.0 -- D:\code projects\back end\armada den\armada-den\venv\Scripts\python.exe
cachedir: .pytest_cache
rootdir: D:\code projects\back end\armada den\armada-den
configfile: pyproject.toml
plugins: anyio-4.11.0, asyncio-1.2.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 1 item

tests/test_reaction_logic.py::test_single_reaction_per_user ERROR        [100%]

=================================== ERRORS ====================================
_______________ ERROR at setup of test_single_reaction_per_user _______________

self = JSONB(astext_type=Text())
visitor = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x000002E75F2D0BF0>
kw = {'type_expression': Column('details', JSONB(astext_type=Text()), table=<audit_logs>)}

    def _compiler_dispatch(
        self: Visitable, visitor: Any, **kw: Any
    ) -> str:
        """Look for an attribute named "visit_<visit_name>" on the
        visitor, and call it with the same kw params.
    
        """
        try:
>           meth = getter(visitor)
                   ^^^^^^^^^^^^^^^
E           AttributeError: 'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'. Did you mean: 'visit_JSON'?

venv\Lib\site-packages\sqlalchemy\sql\visitors.py:134: AttributeError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x000002E75F316BD0>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x000002E75F3162D0>, kw = {}
table = Table('audit_logs', MetaData(), Column('id', UUID(), table=<audit_logs>, primary_key=True, nullable=False, default=Cal...s>, server_default=DefaultClause(<sqlalchemy.sql.functions.now at 0x2e743463710; now>, for_update=False)), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x000002E75F2D2510>
text = '\nCREATE TABLE audit_logs (\n\tid UUID NOT NULL, \n\tuser_id UUID NOT NULL, \n\taction VARCHAR NOT NULL, \n\tentity_type VARCHAR, \n\tentity_id UUID'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x000002E75F316C60>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
>               processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )

venv\Lib\site-packages\sqlalchemy\sql\compiler.py:6769: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\sqlalchemy\sql\compiler.py:932: in process
    return obj._compiler_dispatch(self, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\sql\visitors.py:138: in _compiler_dispatch
    return meth(self, **kw)  # type: ignore  # noqa: E501
           ^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\sql\compiler.py:6800: in visit_create_column
    text = self.get_column_specification(column, first_pk=first_pk)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\dialects\sqlite\base.py:1692: in get_column_specification
    coltype = self.dialect.type_compiler_instance.process(
venv\Lib\site-packages\sqlalchemy\sql\compiler.py:977: in process
    return type_._compiler_dispatch(self, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\sql\visitors.py:136: in _compiler_dispatch
    return visitor.visit_unsupported_compilation(self, err, **kw)  # type: ignore  # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x000002E75F2D0BF0>
element = JSONB(astext_type=Text())
err = AttributeError("'SQLiteTypeCompiler' object has no attribute 'visit_JSONB'")
kw = {'type_expression': Column('details', JSONB(astext_type=Text()), table=<audit_logs>)}

    def visit_unsupported_compilation(
        self, element: Any, err: Exception, **kw: Any
    ) -> NoReturn:
>       raise exc.UnsupportedCompilationError(self, element) from err
E       sqlalchemy.exc.UnsupportedCompilationError: Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x000002E75F2D0BF0> can't render element of type JSONB (Background on this error at: https://sqlalche.me/e/20/l7de)

venv\Lib\site-packages\sqlalchemy\sql\compiler.py:982: UnsupportedCompilationError

The above exception was the direct cause of the following exception:

    @pytest_asyncio.fixture
    async def client():
        test_engine = create_async_engine(
            "sqlite+aiosqlite:///:memory:",
            connect_args={"check_same_thread": False},
            poolclass=StaticPool,
        )
        TestingSessionLocal = async_sessionmaker(test_engine, expire_on_commit=False)
    
        async with test_engine.begin() as conn:
>           await conn.run_sync(Base.metadata.create_all)

tests\test_reaction_logic.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\sqlalchemy\ext\asyncio\engine.py:888: in run_sync
    return await greenlet_spawn(
venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\sql\schema.py:5928: in create_all
    bind._run_ddl_visitor(
venv\Lib\site-packages\sqlalchemy\engine\base.py:2459: in _run_ddl_visitor
    ).traverse_single(element)
      ^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\sql\visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\sql\ddl.py:984: in visit_metadata
    self.traverse_single(
venv\Lib\site-packages\sqlalchemy\sql\visitors.py:661: in traverse_single
    return meth(obj, **kw)
           ^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\sql\ddl.py:1022: in visit_table
    )._invoke_with(self.connection)
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\sql\ddl.py:321: in _invoke_with
    return bind.execute(self)
           ^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
venv\Lib\site-packages\sqlalchemy\sql\ddl.py:187: in _execute_on_connection
    return connection._execute_ddl(
venv\Lib\site-packages\sqlalchemy\engine\base.py:1527: in _execute_ddl
    compiled = ddl.compile(
venv\Lib\site-packages\sqlalchemy\sql\elements.py:311: in compile
    return self._compiler(dialect, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\sql\ddl.py:76: in _compiler
    return dialect.ddl_compiler(dialect, self, **kw)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\sql\compiler.py:886: in __init__
    self.string = self.process(self.statement, **compile_kwargs)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\sql\compiler.py:932: in process
    return obj._compiler_dispatch(self, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\sql\visitors.py:138: in _compiler_dispatch
    return meth(self, **kw)  # type: ignore  # noqa: E501
           ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.base.SQLiteDDLCompiler object at 0x000002E75F316BD0>
create = <sqlalchemy.sql.ddl.CreateTable object at 0x000002E75F3162D0>, kw = {}
table = Table('audit_logs', MetaData(), Column('id', UUID(), table=<audit_logs>, primary_key=True, nullable=False, default=Cal...s>, server_default=DefaultClause(<sqlalchemy.sql.functions.now at 0x2e743463710; now>, for_update=False)), schema=None)
preparer = <sqlalchemy.dialects.sqlite.base.SQLiteIdentifierPreparer object at 0x000002E75F2D2510>
text = '\nCREATE TABLE audit_logs (\n\tid UUID NOT NULL, \n\tuser_id UUID NOT NULL, \n\taction VARCHAR NOT NULL, \n\tentity_type VARCHAR, \n\tentity_id UUID'
create_table_suffix = '', separator = ', \n', first_pk = True
create_column = <sqlalchemy.sql.ddl.CreateColumn object at 0x000002E75F316C60>

    def visit_create_table(self, create, **kw):
        table = create.element
        preparer = self.preparer
    
        text = "\nCREATE "
        if table._prefixes:
            text += " ".join(table._prefixes) + " "
    
        text += "TABLE "
        if create.if_not_exists:
            text += "IF NOT EXISTS "
    
        text += preparer.format_table(table) + " "
    
        create_table_suffix = self.create_table_suffix(table)
        if create_table_suffix:
            text += create_table_suffix + " "
    
        text += "("
    
        separator = "\n"
    
        # if only one primary key, specify it along with the column
        first_pk = False
        for create_column in create.columns:
            column = create_column.element
            try:
                processed = self.process(
                    create_column, first_pk=column.primary_key and not first_pk
                )
                if processed is not None:
                    text += separator
                    separator = ", \n"
                    text += "\t" + processed
                if column.primary_key:
                    first_pk = True
            except exc.CompileError as ce:
>               raise exc.CompileError(
                    "(in table '%s', column '%s'): %s"
                    % (table.description, column.name, ce.args[0])
                ) from ce
E               sqlalchemy.exc.CompileError: (in table 'audit_logs', column 'details'): Compiler <sqlalchemy.dialects.sqlite.base.SQLiteTypeCompiler object at 0x000002E75F2D0BF0> can't render element of type JSONB

venv\Lib\site-packages\sqlalchemy\sql\compiler.py:6779: CompileError
============================== warnings summary ===============================
app\schemas\user.py:26
  D:\code projects\back end\armada den\armada-den\app\schemas\user.py:26: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class LastMessageInfo(BaseModel):

app\schemas\user.py:37
  D:\code projects\back end\armada den\armada-den\app\schemas\user.py:37: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class UserListItem(BaseModel):

app\schemas\chat.py:30
  D:\code projects\back end\armada den\armada-den\app\schemas\chat.py:30: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ChatRoomMemberRead(BaseModel):

app\schemas\chat.py:47
  D:\code projects\back end\armada den\armada-den\app\schemas\chat.py:47: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ChatRoomRead(BaseModel):

app\schemas\chat.py:92
  D:\code projects\back end\armada den\armada-den\app\schemas\chat.py:92: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class MessageReadReceiptRead(BaseModel):

app\schemas\chat.py:102
  D:\code projects\back end\armada den\armada-den\app\schemas\chat.py:102: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ChatMessageRead(BaseModel):

app\schemas\conversation.py:37
  D:\code projects\back end\armada den\armada-den\app\schemas\conversation.py:37: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class MessageResponse(MessageBase):

app\schemas\conversation.py:67
  D:\code projects\back end\armada den\armada-den\app\schemas\conversation.py:67: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ConversationResponse(ConversationBase):

app\schemas\conversation.py:80
  D:\code projects\back end\armada den\armada-den\app\schemas\conversation.py:80: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ConversationWithMessages(ConversationResponse):

app\schemas\channel.py:29
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:29: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ChannelRead(BaseModel):

app\schemas\channel.py:73
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:73: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class TopicMemberRead(BaseModel):

app\schemas\channel.py:104
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:104: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class UserForTopicAddition(BaseModel):

app\schemas\channel.py:116
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:116: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class TopicRead(BaseModel):

app\schemas\channel.py:169
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:169: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class MentionRead(BaseModel):

app\schemas\channel.py:184
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:184: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ReactionRead(BaseModel):

app\schemas\channel.py:207
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:207: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class TopicMessageRead(BaseModel):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
ERROR tests/test_reaction_logic.py::test_single_reaction_per_user - sqlalchem...
======================= 16 warnings, 1 error in 11.37s ========================
