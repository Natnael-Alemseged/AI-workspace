============================= test session starts =============================
platform win32 -- Python 3.12.10, pytest-8.4.2, pluggy-1.6.0 -- D:\code projects\back end\armada den\armada-den\venv\Scripts\python.exe
cachedir: .pytest_cache
rootdir: D:\code projects\back end\armada den\armada-den
configfile: pyproject.toml
plugins: anyio-4.11.0, asyncio-1.2.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 2 items

tests/test_reaction_service.py::test_single_reaction_per_user_per_message FAILED [ 50%]
tests/test_reaction_service.py::test_same_reaction_twice_returns_existing FAILED [100%]

================================== FAILURES ===================================
__________________ test_single_reaction_per_user_per_message __________________

self = <sqlalchemy.engine.base.Connection object at 0x0000025712D023F0>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x0000025712D94170>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x00000257130E0170>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x00000257130E0140>
parameters = [('a1804adf69874a27bc029bf122d44ed6', '86cdf17fdd0e43bcb9e847dab5189d5e', 'Test Topic', 'Test', None, None, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
venv\Lib\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
venv\Lib\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
venv\Lib\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
venv\Lib\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
venv\Lib\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\aiosqlite\core.py:122: in _execute
    return await future
           ^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Connection(Thread-1, started daemon 33452)>

    def run(self) -> None:
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            tx_item = self._tx.get()
            if tx_item is _STOP_RUNNING_SENTINEL:
                break
    
            future, function = tx_item
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
                         ^^^^^^^^^^
E               sqlite3.IntegrityError: NOT NULL constraint failed: topics.created_by

venv\Lib\site-packages\aiosqlite\core.py:105: IntegrityError

The above exception was the direct cause of the following exception:

session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x0000025712E77920>

    @pytest.mark.anyio
    async def test_single_reaction_per_user_per_message(session):
        """Test that a user can only have one reaction per message."""
    
        # Create test user
        user = User(
            id=uuid4(),
            email="test@example.com",
            hashed_password="hashed",
            is_active=True,
            is_superuser=False,
            is_verified=True
        )
        session.add(user)
    
        # Create channel
        channel = Channel(
            id=uuid4(),
            name="Test Channel",
            description="Test",
            created_by=user.id
        )
        session.add(channel)
    
        # Create topic
        topic = Topic(
            id=uuid4(),
            channel_id=channel.id,
            name="Test Topic",
            description="Test"
        )
        session.add(topic)
    
        # Create topic member
        member = TopicMember(
            topic_id=topic.id,
            user_id=user.id
        )
        session.add(member)
    
        # Create message
        message = TopicMessage(
            id=uuid4(),
            topic_id=topic.id,
            sender_id=user.id,
            content="Test message"
        )
        session.add(message)
    
>       await session.commit()

tests\test_reaction_service.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\sqlalchemy\ext\asyncio\session.py:1000: in commit
    await greenlet_spawn(self.sync_session.commit)
venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\orm\session.py:2030: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\orm\session.py:1311: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\orm\session.py:1286: in _prepare_impl
    self.session.flush()
venv\Lib\site-packages\sqlalchemy\orm\session.py:4331: in flush
    self._flush(objects)
venv\Lib\site-packages\sqlalchemy\orm\session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv\Lib\site-packages\sqlalchemy\orm\session.py:4427: in _flush
    flush_context.execute()
venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
venv\Lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
venv\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
venv\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
venv\Lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
venv\Lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
venv\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
venv\Lib\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
venv\Lib\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
venv\Lib\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
venv\Lib\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
venv\Lib\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\aiosqlite\core.py:122: in _execute
    return await future
           ^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Connection(Thread-1, started daemon 33452)>

    def run(self) -> None:
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            tx_item = self._tx.get()
            if tx_item is _STOP_RUNNING_SENTINEL:
                break
    
            future, function = tx_item
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
                         ^^^^^^^^^^
E               sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: topics.created_by
E               [SQL: INSERT INTO topics (id, channel_id, name, description, created_by, updated_at, is_active, is_pinned) VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING created_at]
E               [parameters: ('a1804adf69874a27bc029bf122d44ed6', '86cdf17fdd0e43bcb9e847dab5189d5e', 'Test Topic', 'Test', None, None, 1, 0)]
E               (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv\Lib\site-packages\aiosqlite\core.py:105: IntegrityError
__________________ test_same_reaction_twice_returns_existing __________________

self = <sqlalchemy.engine.base.Connection object at 0x00000257130E1700>
dialect = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteDialect_aiosqlite object at 0x0000025712DE7740>
context = <sqlalchemy.dialects.sqlite.aiosqlite.SQLiteExecutionContext_aiosqlite object at 0x00000257131CFD40>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x00000257131CFC50>
parameters = [('0dc24229fd7045308344549de29db4db', 'f2384ec7bb2243758b9231472d14b12b', 'Test Topic', 'Test', None, None, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
venv\Lib\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
venv\Lib\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
venv\Lib\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
venv\Lib\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
venv\Lib\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\aiosqlite\core.py:122: in _execute
    return await future
           ^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Connection(Thread-2, started daemon 31568)>

    def run(self) -> None:
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            tx_item = self._tx.get()
            if tx_item is _STOP_RUNNING_SENTINEL:
                break
    
            future, function = tx_item
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
                         ^^^^^^^^^^
E               sqlite3.IntegrityError: NOT NULL constraint failed: topics.created_by

venv\Lib\site-packages\aiosqlite\core.py:105: IntegrityError

The above exception was the direct cause of the following exception:

session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x0000025712DE7410>

    @pytest.mark.anyio
    async def test_same_reaction_twice_returns_existing(session):
        """Test that adding the same reaction twice returns the existing one."""
    
        # Create test user
        user = User(
            id=uuid4(),
            email="test2@example.com",
            hashed_password="hashed",
            is_active=True,
            is_superuser=False,
            is_verified=True
        )
        session.add(user)
    
        # Create channel
        channel = Channel(
            id=uuid4(),
            name="Test Channel",
            description="Test",
            created_by=user.id
        )
        session.add(channel)
    
        # Create topic
        topic = Topic(
            id=uuid4(),
            channel_id=channel.id,
            name="Test Topic",
            description="Test"
        )
        session.add(topic)
    
        # Create topic member
        member = TopicMember(
            topic_id=topic.id,
            user_id=user.id
        )
        session.add(member)
    
        # Create message
        message = TopicMessage(
            id=uuid4(),
            topic_id=topic.id,
            sender_id=user.id,
            content="Test message"
        )
        session.add(message)
    
>       await session.commit()

tests\test_reaction_service.py:184: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\sqlalchemy\ext\asyncio\session.py:1000: in commit
    await greenlet_spawn(self.sync_session.commit)
venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\orm\session.py:2030: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\orm\session.py:1311: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\orm\session.py:1286: in _prepare_impl
    self.session.flush()
venv\Lib\site-packages\sqlalchemy\orm\session.py:4331: in flush
    self._flush(objects)
venv\Lib\site-packages\sqlalchemy\orm\session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
venv\Lib\site-packages\sqlalchemy\orm\session.py:4427: in _flush
    flush_context.execute()
venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
venv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
venv\Lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
venv\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
venv\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
venv\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
venv\Lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
venv\Lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
venv\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
venv\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
venv\Lib\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:180: in execute
    self._adapt_connection._handle_exception(error)
venv\Lib\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:340: in _handle_exception
    raise error
venv\Lib\site-packages\sqlalchemy\dialects\sqlite\aiosqlite.py:162: in execute
    self.await_(_cursor.execute(operation, parameters))
venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
venv\Lib\site-packages\aiosqlite\cursor.py:40: in execute
    await self._execute(self._cursor.execute, sql, parameters)
venv\Lib\site-packages\aiosqlite\cursor.py:32: in _execute
    return await self._conn._execute(fn, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\aiosqlite\core.py:122: in _execute
    return await future
           ^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Connection(Thread-2, started daemon 31568)>

    def run(self) -> None:
        """
        Execute function calls on a separate thread.
    
        :meta private:
        """
        while True:
            # Continues running until all queue items are processed,
            # even after connection is closed (so we can finalize all
            # futures)
    
            tx_item = self._tx.get()
            if tx_item is _STOP_RUNNING_SENTINEL:
                break
    
            future, function = tx_item
    
            try:
                LOG.debug("executing %s", function)
>               result = function()
                         ^^^^^^^^^^
E               sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: topics.created_by
E               [SQL: INSERT INTO topics (id, channel_id, name, description, created_by, updated_at, is_active, is_pinned) VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING created_at]
E               [parameters: ('0dc24229fd7045308344549de29db4db', 'f2384ec7bb2243758b9231472d14b12b', 'Test Topic', 'Test', None, None, 1, 0)]
E               (Background on this error at: https://sqlalche.me/e/20/gkpj)

venv\Lib\site-packages\aiosqlite\core.py:105: IntegrityError
============================== warnings summary ===============================
app\schemas\channel.py:29
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:29: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ChannelRead(BaseModel):

app\schemas\channel.py:73
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:73: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class TopicMemberRead(BaseModel):

app\schemas\channel.py:104
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:104: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class UserForTopicAddition(BaseModel):

app\schemas\channel.py:116
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:116: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class TopicRead(BaseModel):

app\schemas\channel.py:169
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:169: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class MentionRead(BaseModel):

app\schemas\channel.py:184
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:184: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ReactionRead(BaseModel):

app\schemas\channel.py:207
  D:\code projects\back end\armada den\armada-den\app\schemas\channel.py:207: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class TopicMessageRead(BaseModel):

app\schemas\chat.py:30
  D:\code projects\back end\armada den\armada-den\app\schemas\chat.py:30: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ChatRoomMemberRead(BaseModel):

app\schemas\chat.py:47
  D:\code projects\back end\armada den\armada-den\app\schemas\chat.py:47: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ChatRoomRead(BaseModel):

app\schemas\chat.py:92
  D:\code projects\back end\armada den\armada-den\app\schemas\chat.py:92: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class MessageReadReceiptRead(BaseModel):

app\schemas\chat.py:102
  D:\code projects\back end\armada den\armada-den\app\schemas\chat.py:102: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ChatMessageRead(BaseModel):

app\schemas\conversation.py:37
  D:\code projects\back end\armada den\armada-den\app\schemas\conversation.py:37: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class MessageResponse(MessageBase):

app\schemas\conversation.py:67
  D:\code projects\back end\armada den\armada-den\app\schemas\conversation.py:67: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ConversationResponse(ConversationBase):

app\schemas\conversation.py:80
  D:\code projects\back end\armada den\armada-den\app\schemas\conversation.py:80: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    class ConversationWithMessages(ConversationResponse):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/test_reaction_service.py::test_single_reaction_per_user_per_message
FAILED tests/test_reaction_service.py::test_same_reaction_twice_returns_existing
======================= 2 failed, 14 warnings in 8.12s ========================
